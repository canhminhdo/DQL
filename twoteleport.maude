load DQL.maude

mod TWO-TELEPORT is
    pr DQL-SEMANTICS .

    var S : Scalar .

    --- defining initial states
    ops a b c d : -> Scalar .
    eq Pow(Abs(a), 2) .+ Pow(Abs(b), 2) = 1 .
    eq S .* Pow(Abs(a), 2) .+ S .* Pow(Abs(b), 2) = S .

    eq Pow(Abs(c), 2) .+ Pow(Abs(d), 2) = 1 .
    eq S .* Pow(Abs(c), 2) .+ S .* Pow(Abs(d), 2) = S .

    op initQState : -> Qubit .
    eq initQState = (q[0]: a . |0> + b . |1>) (q[1]: |0>) (q[2]: |0>) (q[3]: |0>) (q[4]: |0>) (q[5]: c . |0> + d . |1>) .

    op targetQState : -> Qubit .
    eq targetQState = (q[0 1]: (a . |0> + b . |1>) (x) (c . |0> + d . |1>)) .
endm

mod TWO-TELEPORT-CHECK is
    pr TWO-TELEPORT .
    pr CLOSED-SUBSPACES .

    --- defining the subspaces for atomic formulas
    ops prop prop1 prop2 : -> AtomicFormula [ctor] .
    eq V(prop1) = { qubitAt(initQState, 0) } .
    eq V(prop2) = { qubitAt(initQState, 5) } .

    var Q : Qubit .
    var M : Matrix .

    --- checking atomic formulas for Teleportation
    eq Q |= prop = (qubitAt(Q, 2) in V(prop1)) /\ (qubitAt(Q, 3) in V(prop2)) [print "Q = " Q] .
endm

in debug.maude

search in TWO-TELEPORT-CHECK : initQState |= [ H(1) ; CX(1, 2) ; H(3) ; CX(3, 4); CX(0, 1) ; H(0) ; CX(5, 4) ; H(5) ;
if
    P(4, |0>) ->
        if
            P(5, |0>) ->
                if
                    P(1, |0>) ->
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                    |
                    P(1, |1>) -> X(2) ;
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                fi
            |
            P(5, |1>) -> Z(3) ;
                if
                    P(1, |0>) ->
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                    |
                    P(1, |1>) -> X(2) ;
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                fi
        fi
    |
    P(4, |1>) -> X(3) ;
        if
            P(5, |0>) ->
                if
                    P(1, |0>) ->
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                    |
                    P(1, |1>) -> X(2) ;
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                fi
            |
            P(5, |1>) -> Z(3) ;
                if
                    P(1, |0>) ->
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                    |
                    P(1, |1>) -> X(2) ;
                        if
                            P(0, |0>) -> skip
                            |
                            P(0, |1>) -> Z(2)
                        fi
                fi
        fi
fi
] prop =>! JS:JudgementSet such that JS:JudgementSet =/= emptyJS .
