in symbolic-reasoning.maude .

fmod BDQL is
    pr MATRIX .

    --- programs
    sorts AtomicProg Prog .
    subsort AtomicProg < Prog .

    --- atomic programs
    op I`(_`) : Nat -> AtomicProg .
    op X`(_`) : Nat -> AtomicProg .
    op Y`(_`) : Nat -> AtomicProg .
    op Z`(_`) : Nat -> AtomicProg .
    op H`(_`) : Nat -> AtomicProg .
    op CX`(_,_`) : Nat Nat -> AtomicProg .

    --- idenity denotes the end of programs
    ops abort skip : -> Prog [ctor] .
    op _;_ : Prog Prog -> Prog [ctor assoc id: skip prec 25] .
    op _U_ : Prog Prog -> Prog .
    op _* : Prog -> Prog .
    op _? : Formula -> Prog [prec 24] .

    --- formulas
    sorts AtomicFormula Formula .
    subsort AtomicFormula < Formula .

    --- quantum dynamic logic formulas
    op P`(_,_`) : Nat Matrix -> AtomicFormula .
    op P`(_,_,_`) : Nat Nat Matrix -> AtomicFormula .
    op _/\_ : Formula Formula -> Formula [assoc comm] .
    op neg_ : Formula -> Formula .
    op `[_`]_ : Prog Formula -> Formula .

    --- if_then_else_fi commands
    op if_then_else_ fi : Formula Prog Prog -> Prog .
    eq if F:Formula then P1:Prog else P2:Prog fi =
    (F:Formula ? ; P1:Prog) U ((neg F:Formula) ? ; P2:Prog) .
endfm

mod BDQL-SEMANTICS is
    pr SYMBOLIC-REASONING .
    pr BDQL .

    sorts Judgment JudgmentSet .
    subsort Judgment < JudgmentSet .

    op _|=_ : QState Formula -> Judgment .
    op emptyJS : -> JudgmentSet .
    op _/\_ : JudgmentSet JudgmentSet -> JudgmentSet [ctor comm assoc id: emptyJS] .

    vars PROG PROG' : Prog .
    vars Q Q' : QState .
    vars N N1 N2 : Nat .
    var M : Matrix .
    vars Phi Psi : Formula .

    --- projections
    ceq Q |= P(N, M) = emptyJS if (Q).P(N, M) == Q .
    ceq Q |= P(N1, N2, M) = emptyJS if (Q).P(N1, N2, M) == Q .
    --- negation
    eq neg P(N, |0>) = P(N, |1>) .
    eq neg P(N, |1>) = P(N, |0>) .
    --- conjunction
    eq Q |= Phi /\ Psi = (Q |= Phi) /\ (Q |= Psi) .
    --- atomic programs
    eq Q |= [I(N)] Phi = Q |= Phi .
    ceq Q |= [X(N)] Phi = Q' |= Phi if Q' := (Q).X(N) .
    ceq Q |= [Y(N)] Phi = Q' |= Phi if Q' := (Q).Y(N) .
    ceq Q |= [Z(N)] Phi = Q' |= Phi if Q' := (Q).Z(N) .
    ceq Q |= [H(N)] Phi = Q' |= Phi if Q' := (Q).H(N) .
    ceq Q |= [CX(N1, N2)] Phi = Q' |= Phi if Q' := (Q).CX(N1, N2) .
    --- a projection as test operator
    ceq Q |= [P(N, M)?] Phi = Q' |= Phi if Q' := (Q).P(N, M) .
    --- constant programs
    eq Q |= [skip] Phi = Q |= Phi .
    eq Q |= [abort] Phi = emptyJS .
    --- program composition
    ceq Q |= [PROG' ; PROG] Phi = Q |= [PROG']([PROG] Phi) if PROG' =/= skip and-then PROG =/= skip .
    --- choice programs
    eq [choice] : Q |= [PROG' U PROG] Phi = (Q |= [PROG'] Phi) /\ (Q |= [PROG] Phi) .
endm