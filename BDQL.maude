in symbolic-reasoning.maude .

fmod BDQL-SYNTAX is
    pr MATRIX .

    --- programs
    sorts AtomicProg Prog .
    subsort AtomicProg < Prog .

    --- atomic programs
    op I`(_`) : Nat -> AtomicProg [ctor] .
    op X`(_`) : Nat -> AtomicProg [ctor] .
    op Y`(_`) : Nat -> AtomicProg [ctor] .
    op Z`(_`) : Nat -> AtomicProg [ctor] .
    op H`(_`) : Nat -> AtomicProg [ctor] .
    op CX`(_,_`) : Nat Nat -> AtomicProg [ctor] .

    --- idenity denotes the end of programs
    ops abort skip : -> Prog [ctor] .
    op _;_ : Prog Prog -> Prog [ctor assoc id: skip prec 25] .
    op _U_ : Prog Prog -> Prog [ctor assoc comm prec 26] .
    op _* : Prog -> Prog [ctor] .
    op _? : Formula -> AtomicProg [ctor prec 24] .

    --- formulas
    sorts AtomicFormula Formula .
    subsort AtomicFormula < Formula .

    --- quantum dynamic logic formulas
    op P`(_,_`) : Nat Matrix -> AtomicFormula [ctor] .
    op P`(_,_,_`) : Nat Nat Matrix -> AtomicFormula [ctor] .
    op _/\_ : Formula Formula -> Formula [ctor assoc comm] .
    op neg_ : Formula -> Formula .
    op `[_`]_ : Prog Formula -> Formula [ctor] .

    --- if_then_else_fi commands
    op if_then_else_ fi : Formula Prog Prog -> Prog .
    eq if F:Formula then P1:Prog else P2:Prog fi =
    (F:Formula ? ; P1:Prog) U ((neg F:Formula) ? ; P2:Prog) .
endfm

fmod BDQL-SEMANTICS is
    pr SYMBOLIC-REASONING .
    pr BDQL-SYNTAX .

    sorts Judgment JudgmentSet .
    subsort Judgment < JudgmentSet .

    op _|=_ : QState Formula -> Judgment .
    op emptyJS : -> JudgmentSet [ctor] .
    op _/\_ : JudgmentSet JudgmentSet -> JudgmentSet [comm assoc id: emptyJS] .

    vars PROG PROG' PROG'' : Prog .
    vars Q Q' : QState .
    vars N N1 N2 : Nat .
    var M : Matrix .
    vars Phi Psi : Formula .

    --- abort is the identity element for U
    eq PROG U abort = PROG .
    eq abort U PROG = PROG .
    --- annihilation by abort
    ceq PROG ; abort = abort if PROG =/= skip .
    ceq abort ; PROG = abort if PROG =/= skip .
    --- choice is idempotent
    eq PROG U PROG = PROG .
    --- ; distributes over U
    ceq PROG ; (PROG' U PROG'') = (PROG ; PROG') U (PROG ; PROG'') if PROG =/= skip .
    ceq (PROG U PROG') ; PROG'' = (PROG ; PROG'') U (PROG' ; PROG'') if PROG'' =/= skip .

    --- projections
    ceq Q |= P(N, M) = emptyJS if (Q).P(N, M) == Q .
    ceq Q |= P(N1, N2, M) = emptyJS if (Q).P(N1, N2, M) == Q .
    --- negation
    eq neg P(N, |0>) = P(N, |1>) .
    eq neg P(N, |1>) = P(N, |0>) .
    --- conjunction
    eq Q |= Phi /\ Psi = (Q |= Phi) /\ (Q |= Psi) .
    --- atomic programs
    eq Q |= [I(N)] Phi = Q |= Phi .
    ceq Q |= [X(N)] Phi = Q' |= Phi if Q' := (Q).X(N) .
    ceq Q |= [Y(N)] Phi = Q' |= Phi if Q' := (Q).Y(N) .
    ceq Q |= [Z(N)] Phi = Q' |= Phi if Q' := (Q).Z(N) .
    ceq Q |= [H(N)] Phi = Q' |= Phi if Q' := (Q).H(N) .
    ceq Q |= [CX(N1, N2)] Phi = Q' |= Phi if Q' := (Q).CX(N1, N2) .
    --- a projection as test operator
    ceq Q |= [P(N, M)?] Phi = Q' |= Phi if Q' := (Q).P(N, M) .
    --- constant programs
    eq Q |= [skip] Phi = Q |= Phi .
    eq Q |= [abort] Phi = emptyJS .
    --- program composition
    ceq Q |= [PROG' ; PROG] Phi = Q |= [PROG']([PROG] Phi) if PROG' =/= skip and-then PROG =/= skip .
    --- choice programs
    eq [choice] : Q |= [PROG' U PROG] Phi = (Q |= [PROG'] Phi) /\ (Q |= [PROG] Phi) .
endfm