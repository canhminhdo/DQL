in ../BDQL.maude .

fmod BDQL-EXT is
    pr BDQL-SEMANTICS .

    sort Channel .

    --- merge operator (parallel composition), left-merge operator, communcation operator
    op _||_ : Prog Prog -> Prog [comm assoc] .
    op _||'_ : Prog Prog -> Prog .
    op _|_ : Prog Prog -> Prog [comm assoc] .

    --- sending
    ops _<:_ send : Channel Nat -> AtomicProg [ctor] .
    --- receiving
    ops _:>_ recv : Channel Nat -> AtomicProg [ctor] .

    --- deadlock
    op dlk : -> Prog [ctor] .

    --- communication function
    op _~_ : AtomicProg AtomicProg -> Prog [comm prec 24] .
endfm

view AtomicProg from TRIV to BDQL-EXT is
    sort Elt to AtomicProg .
endv

fmod BDQL-FULL is
    pr BDQL-EXT .
    pr SET{AtomicProg} * (
        sort NeSet{AtomicProg} to NeAtomicProgSet, sort Set{AtomicProg} to AtomicProgSet
    ) .

    --- encapsulation operator
    op encap(_)[_] : Prog AtomicProgSet -> Prog .

    vars C C1 C2 : Channel .
    vars N N1 N2 : Nat .
    vars AP AP' : AtomicProg .
    vars PROG PROG' PROG'' : Prog .
    vars APS APS' : AtomicProgSet .

    var Q : QState .
    var Phi : Formula .

    --- for deadlock
    eq Q |= [dlk] Phi = emptyJS [print "DEADLOCK"] .

    --- axioms for deadlock
    eq PROG U dlk = PROG .
    eq dlk ; PROG = dlk .
    eq dlk ||' PROG = dlk .
    eq dlk | PROG = dlk .

    --- encapsulation operator
    ceq encap(AP)[APS] = AP if not (AP in APS) .
    ceq encap(AP)[APS] = dlk if AP in APS .
    eq encap(skip)[APS] = skip .
    eq encap(abort)[APS] = abort .
    eq encap(dlk)[APS] = dlk .
    eq encap(PROG ; PROG')[APS] = encap(PROG)[APS] ; encap(PROG')[APS] .
    eq encap(PROG U PROG')[APS] = encap(PROG)[APS] U encap(PROG')[APS] .

    --- axioms for merge operator
    eq PROG || PROG' = (PROG ||' PROG') U (PROG' ||' PROG) U (PROG | PROG') .

    --- axioms for left operator
    eq skip ||' PROG = PROG .
    eq abort ||' PROG = abort .
    eq AP ||' PROG = AP ; PROG [owise] .

    eq (abort ; PROG) ||' PROG' = abort .
    eq (AP ; PROG) ||' PROG' = AP ; (PROG || PROG') [owise] .
    eq (PROG U PROG') ||' PROG'' = (PROG ||' PROG'') U (PROG' ||' PROG'') .

    --- communication function
    eq send(C, N) ~ recv(C, N) = skip .
    eq (C <: N) ~ (C :> N) = skip .
    eq AP ~ AP' = dlk [owise] .

    --- axioms for communication operator
    eq AP | AP' =  AP ~ AP' .
    eq AP | (AP' ; PROG') = (AP ~ AP') ; PROG' .
    eq (AP ; PROG) | (AP' ; PROG') = (AP ~ AP') ; (PROG || PROG') .
    eq (PROG U PROG') | PROG'' = (PROG | PROG'') U (PROG' | PROG'') .
    eq skip | PROG = dlk .
    eq abort | PROG = dlk .
endfm

--- in ../debug.maude

fmod BDQL-FULL-TEST is
    pr BDQL-FULL .
    ops a1 a2 a3 b1 b2 b3 d1 d2 d3 : -> AtomicProg .
    ops c c1 c2 : -> Channel .
endfm

--- red encap((send(c1, 0) U send(c2, 1)) || (recv(c1, 0) U recv(c2, 1)))[send(c1, 0), send(c2, 1), recv(c1, 0), recv(c2, 1)] .
--- red send(c1, 0) || recv(c1, 0) .
--- red encap(send(c1, 0) || recv(c1, 0))[send(c1, 0)] .
--- red encap(send(c1, 0) || recv(c1, 0))[send(c1, 0), send(c2, 1), recv(c1, 0), recv(c2, 1)] .
--- red (a1 || a2) || a3 == a1 || (a2 || a3) .
--- red (a1 || a2) || a3 .
--- red a1 || (a2 || a3) .
--- red (a1 ; (c <: 0) ; a2) || (b1 ; (c :> 0) ; b2) .
--- red (a1 ; (c1 <: 0) ; a2 ; (c2 <: 0) ; a3) || (b1 ; (c2 :> 0) ; b2 ; (c1 :> 0) ; b3) .