in ../BDQL.maude .

fmod CDQL-SYNTAX is
    pr BDQL-SYNTAX .

    sort Channel .

    --- merge operator (parallel composition), left-merge operator, communcation operator
    op _||_ : Prog Prog -> Prog [comm assoc] .
    op _||'_ : Prog Prog -> Prog .
    op _|_ : Prog Prog -> Prog [comm assoc] .

    --- sending
    ops _<:_ send : Channel Nat -> AtomicProg [ctor] .
    --- receiving
    ops _:>_ recv : Channel Nat -> AtomicProg [ctor] .

    --- communication function
    op _~_ : AtomicProg AtomicProg -> Prog [comm prec 24] .
endfm

view AtomicProg from TRIV to CDQL-SYNTAX is
    sort Elt to AtomicProg .
endv

fmod CDQL-SYNTAX-EXT is
    pr CDQL-SYNTAX .
    pr SET{AtomicProg} * (
        sort NeSet{AtomicProg} to NeAtomicProgSet,
        sort Set{AtomicProg} to AtomicProgSet
    ) .
    --- encapsulation operator
    op encap(_)[_] : Prog AtomicProgSet -> Prog .
endfm

fmod CDQL-SEMANTICS is
    pr CDQL-SYNTAX-EXT .
    pr BDQL-SEMANTICS .

    var N : Nat .
    var C : Channel .
    var A : Formula .
    var APS : AtomicProgSet .
    vars AP AP' : AtomicProg .
    vars PROG PROG' PROG1 PROG2 PROG3 PROG4 : Prog .
    vars Q Q' : QState .
    vars Phi Psi : Formula .

    --- encapsulation for a single element
    ceq Q |= [encap(AP)[APS]] Phi = Q |= [AP] Phi if not (AP in APS) .
    ceq Q |= [encap(AP)[APS]] Phi = Q |= [abort] Phi if AP in APS .
    eq Q |= [encap(skip)[APS]] Phi = Q |= [skip] Phi .
    eq Q |= [encap(abort)[APS]] Phi = Q |= [abort] Phi .
    eq Q |= [encap((A ?))[APS]] Phi = Q |= [(A ?)] Phi .
    
    ceq Q |= [encap(AP)[APS] ; PROG] Phi = Q |= [AP ; PROG] Phi if not (AP in APS) .
    ceq Q |= [encap(AP)[APS] ; PROG] Phi = Q |= [abort ; PROG] Phi if AP in APS .
    eq Q |= [encap(skip)[APS] ; PROG] Phi = Q |= [skip ; PROG] Phi .
    eq Q |= [encap(abort)[APS] ; PROG] Phi = Q |= [abort ; PROG] Phi .
    eq Q |= [encap((A ?))[APS] ; PROG] Phi = Q |= [(A ?) ; PROG] Phi .
    
    --- encapsulation for a single element followed by a program
    ceq Q |= [encap(AP ; PROG)[APS]] Phi = Q |= [AP ; encap(PROG) [APS]] Phi if not (AP in APS) .
    ceq Q |= [encap(AP ; PROG)[APS]] Phi = Q |= [abort ; encap(PROG)[APS]] Phi if AP in APS .
    eq Q |= [encap(skip ; PROG)[APS]] Phi = Q |= [skip ; encap(PROG)[APS]] Phi .
    eq Q |= [encap(abort ; PROG)[APS]] Phi = Q |= [abort ; encap(PROG)[APS]] Phi .
    eq Q |= [encap((A ?) ; PROG)[APS]] Phi = Q |= [(A ?) ; encap(PROG)[APS]] Phi .

    ceq Q |= [encap(AP ; PROG)[APS] ; PROG'] Phi = Q |= [AP ; encap(PROG)[APS] ; PROG'] Phi if not (AP in APS) .
    ceq Q |= [encap(AP ; PROG)[APS] ; PROG'] Phi = Q |= [abort ; encap(PROG)[APS] ; PROG'] Phi if AP in APS .
    eq Q |= [encap(skip ; PROG)[APS] ; PROG'] Phi = Q |= [skip ; encap(PROG)[APS] ; PROG'] Phi .
    eq Q |= [encap(abort ; PROG)[APS] ; PROG'] Phi = Q |= [abort ; encap(PROG)[APS] ; PROG'] Phi .
    eq Q |= [encap((A ?) ; PROG)[APS] ; PROG'] Phi = Q |= [(A ?) ; encap(PROG)[APS] ; PROG'] Phi .
    
    --- [hack]
    eq Q |= [encap(PROG || PROG')[APS]] Phi = Q |= [encap((PROG ||' PROG') U (PROG' ||' PROG) U (PROG | PROG'))[APS]] Phi .
    
    --- encapsulation for non-deterministic choices
    eq Q |= [encap(PROG U PROG')[APS]] Phi = Q |= [encap(PROG)[APS] U encap(PROG')[APS]] Phi .
    eq Q |= [encap(PROG1 U PROG2)[APS] ; PROG3] Phi = Q |= [(encap(PROG1)[APS] U encap(PROG2)[APS]) ; PROG3] Phi .
    
    --- --- encapsulation operator
    --- ceq encap(AP)[APS] = AP if not (AP in APS) .
    --- ceq encap(AP)[APS] = abort if AP in APS .
    --- eq encap(skip)[APS] = skip .
    --- eq encap(abort)[APS] = abort .
    --- eq encap((A ?))[APS] = (A ?) .
    --- eq encap(PROG ; PROG')[APS] = encap(PROG)[APS] ; encap(PROG')[APS] .
    --- eq encap(PROG U PROG')[APS] = encap(PROG)[APS] U encap(PROG')[APS] .

    --- --- axioms for merge operator
    --- eq PROG || PROG' = (PROG ||' PROG') U (PROG' ||' PROG) U (PROG | PROG') .
    eq Q |= [PROG || PROG'] Phi = Q |= [(PROG ||' PROG') U (PROG' ||' PROG) U (PROG | PROG')] Phi .

    --- axioms for left operator
    eq AP ||' PROG = AP ; PROG .
    eq skip ||' PROG = PROG .
    eq abort ||' PROG = abort .
    eq (A ?) ||' PROG = (A ?) ; PROG .

    eq (AP ; PROG) ||' PROG' = AP ; (PROG || PROG') .
    eq (skip ; PROG) ||' PROG' = PROG || PROG' .
    eq (abort ; PROG) ||' PROG' = abort .
    eq ((A ?) ; PROG) ||' PROG' = (A ?) ; (PROG || PROG') .

    eq ((PROG1 ; PROG2) ; PROG3) ||' PROG4 = (PROG1 ; (PROG2 ; PROG3)) ||' PROG4 .
    eq ((PROG1 U PROG2) ; PROG3) ||' PROG4 = ((PROG1 ; PROG3) U (PROG2 ; PROG3)) ||' PROG4 .
    eq (PROG1 U PROG2) ||' PROG3 = (PROG1 ||' PROG3) U (PROG2 ||' PROG3) .
    --- [hack]
    eq (PROG1 || PROG2) ||' PROG3 = ((PROG1 ||' PROG2) U (PROG2 ||' PROG1) U (PROG1 | PROG2)) ||' PROG3 .

    --- communication function
    eq send(C,N) ~ recv(C, N) = skip .
    eq (C <: N) ~ (C :> N) = skip .
    eq AP ~ AP' = abort [owise] .

    --- axioms for communication operator
    eq skip | PROG = abort .
    eq abort | PROG = abort .
    eq (A ?) | PROG = abort .
    eq AP | AP' = AP ~ AP' .
    eq AP | (AP' ; PROG) = (AP ~ AP') ; PROG .

    eq (skip ; PROG) | PROG' = abort .
    eq (abort ; PROG) | PROG' = abort .
    eq ((A ?) ; PROG) | PROG' = abort .
    eq (AP ; PROG) | (AP' ; PROG') = (AP ~ AP') ; (PROG || PROG') .

    eq ((PROG1 ; PROG2) ; PROG3) | PROG4 = (PROG1 ; (PROG2 ; PROG3)) | PROG4 .
    eq ((PROG1 U PROG2) ; PROG3) | PROG4 = ((PROG1 ; PROG3) U (PROG2 ; PROG3)) | PROG4 .
    eq (PROG1 U PROG2) | PROG3 = (PROG1 | PROG3) U (PROG2 | PROG3) .
    --- [hack]
    eq (PROG1 || PROG2) | PROG3 = ((PROG1 ||' PROG2) U (PROG2 ||' PROG1) U (PROG1 | PROG2)) | PROG3 .
endfm

--- in ../debug.maude

--- fmod BDQL-FULL-TEST is
---     pr BDQL-FULL .
---     ops a1 a2 a3 b1 b2 b3 d1 d2 d3 : -> AtomicProg .
---     ops c c1 c2 : -> Channel .
--- endfm

--- red encap((send(c1, 0) U send(c2, 1)) || (recv(c1, 0) U recv(c2, 1)))[send(c1, 0), send(c2, 1), recv(c1, 0), recv(c2, 1)] .
--- red send(c1, 0) || recv(c1, 0) .
--- red encap(send(c1, 0) || recv(c1, 0))[send(c1, 0)] .
--- red encap(send(c1, 0) || recv(c1, 0))[send(c1, 0), send(c2, 1), recv(c1, 0), recv(c2, 1)] .
--- red (a1 || a2) || a3 == a1 || (a2 || a3) .
--- red (a1 || a2) || a3 .
--- red a1 || (a2 || a3) .
--- red (a1 ; (c <: 0) ; a2) || (b1 ; (c :> 0) ; b2) .
--- red (a1 ; (c1 <: 0) ; a2 ; (c2 <: 0) ; a3) || (b1 ; (c2 :> 0) ; b2 ; (c1 :> 0) ; b3) .