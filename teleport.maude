load quantum-computation.maude

mod TELEPORT is
    pr QUANTUM-COMPUTATION .

    var S : Scalar .

    --- defining initial states
    ops a b : -> Scalar .
    eq Pow(Abs(a), 2) .+ Pow(Abs(b), 2) = 1 .
    eq S .* Pow(Abs(a), 2) .+ S .* Pow(Abs(b), 2) = S .

    op initQState : -> Qubit .
    eq initQState = (q[0]: a . |0> + b . |1>) (q[1]: |0>) (q[2]: |0>) .
endm

mod TELEPORT-CHECK is
    pr TELEPORT .
    pr CLOSED-SUBSPACES .

    --- defining the subspaces for atomic formulas
    op prop : -> AtomicFormula [ctor] .
    eq V(prop) = { qubitAt(initQState, 0) } .

    var Q : Qubit .

    --- checking atomic formulas for Teleportation
    eq Q |= prop = qubitAt(Q, 2) in V(prop) .
endm

search in TELEPORT-CHECK : initQState |= [ H(1) ; CX(1, 2) ; CX(0, 1) ; H(0) ;
(
    (M(0, P0)? ; ((M(1, P0)? ; I(2)) U (M(1, P1)? ; X(2))))
    U
    (M(0, P1)? ; ((M(1, P0)? ; Z(2)) U (M(1, P1)? ; Z(2) ; X(2))))
)
] prop =>! JS:JudgementSet such that JS:JudgementSet =/= emptyJS .

search in TELEPORT-CHECK : initQState |= [ H(1) ; CX(1, 2) ; CX(0, 1) ; H(0) ;
if
    (M(0, P0) -> (if (M(1, P0) -> I(2)) | (M(1, P1) -> X(2)) fi))
    |
    (M(0, P1) -> (if (M(1, P0) -> Z(2)) | (M(1, P1) -> Z(2) ; X(2)) fi))
fi
] prop =>! JS:JudgementSet such that JS:JudgementSet =/= emptyJS .
