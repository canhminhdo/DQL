in ../BDQL.maude .

fmod BDQL-FULL is
    pr BDQL-SEMANTICS .

    --- program list
    sort ProgList .
    subsort Prog < ProgList .

    op nil : -> ProgList [ctor] .
    op _|_ : ProgList ProgList -> ProgList [ctor assoc id: nil prec 27] .

    vars PROG PROG' PROG'' : Prog .
    vars L L1 L2 L3 : ProgList .

    --- op head : ProgList -> Prog .
    --- op tail : ProgList -> ProgList .
    --- eq head(PROG | L) = PROG .
    --- eq head(L) = L [owise] .
    --- eq tail(PROG | L) = L .
    --- eq tail(L) = L [owise] .

    --- parallel composition
    sort Channel .
    --- parallel composition operator for two operands
    op _||_ : ProgList ProgList -> Prog [comm] .
    --- sending
    op _<:_ : Channel Nat -> AtomicProg [ctor] .
    --- receiving
    op _:>_ : Channel Nat -> AtomicProg [ctor] .

    vars C C1 C2 : Channel .
    vars N N1 N2 : Nat .

    --- channels and messages
    op ch : AtomicProg -> Channel .
    op msg : AtomicProg -> Nat .
    eq ch(C <: N) = C .
    eq msg(C <: N) = N .

    --- whether first command is a communication command
    op firstComm : Prog -> Bool .
    eq firstComm((C <: N) ; PROG) = true .
    eq firstComm((C :> N) ; PROG) = true .
    eq firstComm(PROG) = false [owise] .
    op hasComm : Prog -> Bool .
    eq hasComm(PROG ; (C <: N) ; PROG') = true .
    eq hasComm(PROG ; (C :> N) ; PROG') = true .
    eq hasComm(PROG) = false [owise] .

    eq (PROG U PROG') | L1 || L2 = ((PROG | L1) || L2) U ((PROG' | L1) || L2) .

    eq (((C <: N) ; PROG) | L) || nil = abort .
    eq (((C :> N) ; PROG) | L) || nil = abort .
    ceq (PROG | L) || nil = PROG ; (L || nil) if not firstComm(PROG) .
    eq nil || nil = skip .

    eq (((C <: N1) ; PROG) | L1) || (((C <: N2) ; PROG') | L2) = abort .
    eq (((C :> N1) ; PROG) | L1) || (((C :> N2) ; PROG') | L2) = abort .

    eq (((C <: N) ; PROG) | L1) || (((C :> N) ; PROG') | L2) = (PROG | L1) || (PROG' | L2) .
    ceq (((C <: N1); PROG ) | L1) || (((C :> N2) ; PROG') | L2) = abort if N1 =/= N2 .

    ceq (((C <: N) ; PROG) | L1) || (PROG' | L2) = PROG' ; ((((C <: N) ; PROG) | L1) || L2)
    if not firstComm(PROG') /\ not hasComm(PROG') .
    ceq (((C <: N) ; PROG) | L1) || (PROG' | L2) = (((C <: N) ; PROG) | L1) || (split(PROG') | L2)
    if not firstComm(PROG') /\ hasComm(PROG') .

    ceq (((C :> N) ; PROG) | L1) || (PROG' | L2) = PROG' ; ((((C :> N) ; PROG) | L1) || L2)
    if not firstComm(PROG') /\ not hasComm(PROG') .
    ceq (((C :> N) ; PROG) | L1) || (PROG' | L2) = (((C :> N) ; PROG) | L1) || (split(PROG') | L2)
    if not firstComm(PROG') /\ hasComm(PROG') .

    ceq (PROG | L1) || (PROG' | L2) = (PROG ; (L1 || (PROG' | L2))) U (PROG' ; ((PROG | L1) || L2))
    if not firstComm(PROG) /\
    not firstComm(PROG') /\
    not (hasComm(PROG) or-else hasComm(PROG')) .

    ceq (PROG | L1) || (PROG' | L2) = (split(PROG) | L1) || (split(PROG') | L2)
    if not firstComm(PROG) /\
    not firstComm(PROG') /\
    (hasComm(PROG) or-else hasComm(PROG')) .

    op split : Prog -> ProgList .
    ceq split(PROG ; (C <: N) ; PROG') = PROG | (C <: N) ; PROG' if PROG =/= skip .
    eq split(PROG) = PROG [owise] .

    --- parallel composition operator for three operands
    op ||| : ProgList ProgList ProgList -> Prog .
    eq |||(nil, nil, nil) = skip .
    eq |||(nil, nil, (PROG | L)) = PROG ; |||(nil, nil, L) .
    eq |||(nil, (PROG | L), nil) = PROG ; |||(nil, nil, L) .
    eq |||((PROG | L), nil, nil) = PROG ; |||(nil, nil, L) .
    eq |||(nil, (PROG | L1), (PROG' | L2)) = (PROG | L1) || (PROG' | L2) .
    eq |||((PROG | L1), nil, (PROG' | L2)) = (PROG | L1) || (PROG' | L2) .
    eq |||((PROG | L1), (PROG' | L2), nil) = (PROG | L1) || (PROG' | L2) .
    eq |||((PROG | L1), (PROG' | L2), (PROG'' | L3)) =
    (PROG ; |||(L1, (PROG' | L2), (PROG'' | L3))) U
    (PROG' ; |||((PROG | L1), L2, (PROG'' | L3))) U
    (PROG'' ; |||((PROG | L1), (PROG' | L2), L3)) .
endfm

fmod BDQL-FULL-TEST is
    pr BDQL-FULL .
    ops a1 a2 a3 b1 b2 b3 d1 d2 d3 : -> Prog .
    ops c c1 c2 : -> Channel .
endfm

--- red (a1 | a2) || (b1 | b2) .
--- red (a1 ; a2) || (b1 ; b2) .
--- red (a1 | (c <: 0) | a2) || (b1 | (c :> 0) | b2) .
--- red (a1 | (c1 <: 0) | a2 | (c2 <: 0)) || (b1 | (c1 :> 0) | b2) .
--- red (a1 | (c1 <: 0) | a2 | (c2 <: 0) | a3) || (b1 | (c2 <: 0) | a2 | (c1 <: 0) | b3) .
--- red ((c1 <: 0) U (c2 <: 0)) || ((c2 :> 0) ; a1) .
--- red (a1 U a2) || a3 == (a1 || a3) U (a2 || a3) .
--- red (a1 U a2 U a3) || (b1 U b2) .
--- red a1 || b1 U b2 | d1 U d2 .